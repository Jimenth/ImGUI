local Players = game:GetService("Players")
local Mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local box = nil
local closestPlayer = nil
local isKeybindHeld = false
local isVisible = true
local isClicking = false

-- Customize appearance parameters for the box and circle
local Settings = {
    HoldBind = {
        Key = nil, -- Make nil if you want to use a mouse button (Enum.Keycode.V)
        MouseButton = Enum.UserInputType.MouseButton2, -- Make nil if you want to use a keybind (Enum.UserInputType.MouseButton2)
        Options = "Hold" -- Options: "Hold" or "Toggle"
    },
    BoxHideBind = Enum.KeyCode.V, -- Keybind to change visibility of the box
    CircleHideBind = Enum.KeyCode.B, -- Keybind to toggle visibility of the circle
    Cooldown = 200, -- In milliseconds
    VelocityDetection = 43, -- Will stop locking if the person is using a macro or a velocity anti lock.
    Prediction = {
        Enabled = true,
        Value = .12955
    }
}

local boxParams = {
    Size = Vector3.new(4.8, 7.35, 1),
    Color = Color3.new(1, 0, 0),
    OutlineColor = Color3.new(1, 1, 1),
    InitialFillTransparency = 1,
    InitialOutlineTransparency = 0
}

-- Define parameters for the circle
local circleParams = {
    Visible = false,
    Radius = 80, -- Radius of the circle
    Color = Color3.new(255, 255, 255),
    Thickness = 1,
    Transparency = 0.5
}

-- Create a Drawing Circle
local circleDrawing = Drawing.new("Circle")
circleDrawing.Visible = circleParams.Visible
circleDrawing.Radius = circleParams.Radius
circleDrawing.Color = circleParams.Color
circleDrawing.Thickness = circleParams.Thickness
circleDrawing.Transparency = circleParams.Transparency
circleDrawing.Visible = true

-- Convert world position to 2D screen position
local function worldToScreenPosition(position)
    local camera = workspace.CurrentCamera
    local screenPos, onScreen = camera:WorldToScreenPoint(position)
    return screenPos, onScreen
end

-- Function to determine if a player is inside the circle
local function isPlayerInsideCircle(player)
    local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        local playerScreenPos, onScreen = worldToScreenPosition(rootPart.Position)
        if onScreen then
            local distance = (Vector2.new(playerScreenPos.X, playerScreenPos.Y) - Vector2.new(circleDrawing.Position.X, circleDrawing.Position.Y)).magnitude
            return distance <= circleParams.Radius
        end
    end
    return false
end

-- Function to find the closest player to the mouse position
local function findClosestPlayer()
    local closestDist = math.huge
    local closestPlayer = nil
    local mousePos = Mouse.Hit.p
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            local character = player.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local dist = (rootPart.Position - mousePos).magnitude
                    if dist < closestDist and isPlayerInsideCircle(player) then
                        closestDist = dist
                        closestPlayer = player
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

local function updateCirclePosition()
    local screenSize = workspace.CurrentCamera.ViewportSize
    circleDrawing.Position = Vector2.new(screenSize.X / 2, screenSize.Y / 2)
end

-- Function to determine if the mouse is inside the box
local function isMouseInsideBox()
    local mousePos = Mouse.Hit.p
    return mousePos and box and (mousePos - box.Position).magnitude <= box.Size.Magnitude / 2
end

local function Click()
    if Settings.Cooldown > 0 then
        task.wait(Settings.Cooldown / 1000)
    end
    game:GetService('VirtualUser'):ClickButton1(Vector2.new())
    local mouse = LocalPlayer:GetMouse()
    local newPosition = Vector2.new(mouse.X, mouse.Y)
    mouse.Move(newPosition)
end

-- Function to update the box position and camera
local function updateBoxPosition()
    if isKeybindHeld then
        updateCirclePosition() -- Ensure the circle position is updated
        
        closestPlayer = findClosestPlayer()
        
        if closestPlayer then
            local humanoidRootPart = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local velocity = humanoidRootPart.Velocity
                local predictedPosition
                
                -- Determine the predicted position based on velocity
                local cameraPos = workspace.CurrentCamera.CFrame.p
                local playerDirection = (humanoidRootPart.Position - cameraPos).unit
                local playerMovementDirection = velocity.unit
                local dotProduct = playerDirection:Dot(playerMovementDirection)
                local isMovingOnZAxis = math.abs(playerMovementDirection.Z) > 0.7
                local isMovingOnBackwardZ = dotProduct < -0.7 and isMovingOnZAxis
                local isMovingOnForwardZ = dotProduct > 0.7 and isMovingOnZAxis

                if isMovingOnBackwardZ or isMovingOnForwardZ or Settings.Prediction.Enabled == false then
                    predictedPosition = humanoidRootPart.Position
                else
                    predictedPosition = humanoidRootPart.Position + velocity * Settings.Prediction.Value
                end

                -- Create the box if it doesn't exist
                if not box then
                    box = Instance.new("Part")
                    box.Size = boxParams.Size
                    box.Anchored = true
                    box.Transparency = isVisible and boxParams.InitialFillTransparency or 1
                    box.Color = boxParams.Color
                    box.Position = predictedPosition
                    box.Parent = game.Workspace
                    box.CanCollide = false

                    local outline = Instance.new("SelectionBox", box)
                    outline.LineThickness = 0.05
                    outline.Color3 = boxParams.OutlineColor
                    outline.Adornee = box
                    outline.Transparency = isVisible and boxParams.InitialOutlineTransparency or 1
                end

                -- Update the box position and rotation
                box.Position = predictedPosition
                local boxForward = (cameraPos - predictedPosition).unit
                local boxRight = boxForward:Cross(Vector3.new(0, 1, 0)).unit
                local boxUp = boxRight:Cross(boxForward).unit
                box.CFrame = CFrame.fromMatrix(predictedPosition, boxRight, boxUp)

                -- Handle clicking if mouse is inside the box
                if isMouseInsideBox() and not isClicking then
                    isClicking = true
                    task.spawn(function()
                        while isClicking and box and isKeybindHeld do
                            Click()
                            task.wait(Settings.Cooldown / 1000) -- Ensure cooldown is respected
                        end
                        isClicking = false
                    end)
                elseif not isMouseInsideBox() then
                    isClicking = false
                end
            end
        else
            -- Clean up if closest player not found
            if box then
                box:Destroy()
                box = nil
            end
            isClicking = false
        end
    else
        -- Clean up if keybind is not held
        if box then
            box:Destroy()
            box = nil
        end
        isClicking = false
    end
end

-- Function to toggle visibility of the box
local function toggleBoxVisibility()
    isVisible = not isVisible
    
    if box then
        box.Transparency = isVisible and boxParams.InitialFillTransparency or 1
        for _, outline in ipairs(box:GetChildren()) do
            if outline:IsA("SelectionBox") then
                outline.Transparency = isVisible and boxParams.InitialOutlineTransparency or 1
            end
        end
    end
    
    print(isVisible and "Box is now visible" or "Box is now invisible")
end

-- Function to toggle visibility of the circle
local function toggleCircleVisibility()
    circleParams.Visible = not circleParams.Visible
    circleDrawing.Visible = circleParams.Visible
    print(circleParams.Visible and "Circle is now visible" or "Circle is now invisible")
end

-- Connect the RenderStepped event to update positions
game:GetService("RunService").RenderStepped:Connect(function()
    updateBoxPosition()
end)

-- Connect input events for hold bind (keyboard and mouse button), hide bind (keyboard), and circle toggle bind (keyboard)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed then
        if (input.KeyCode == Settings.HoldBind.Key or input.UserInputType == Settings.HoldBind.MouseButton) and Settings.HoldBind.Options == "Toggle" then
            isKeybindHeld = not isKeybindHeld
            if not isKeybindHeld and box then
                box:Destroy()
                box = nil
                isClicking = false
            end
        elseif (input.KeyCode == Settings.HoldBind.Key or input.UserInputType == Settings.HoldBind.MouseButton) and Settings.HoldBind.Options == "Hold" then
            isKeybindHeld = true
        elseif input.KeyCode == Settings.BoxHideBind then
            toggleBoxVisibility()
        elseif input.KeyCode == Settings.CircleHideBind then
            toggleCircleVisibility()
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.KeyCode == Settings.HoldBind.Key and Settings.HoldBind.Options == "Hold" or input.UserInputType == Settings.HoldBind.MouseButton and Settings.HoldBind.Options == "Hold" then
        isKeybindHeld = false
        if box then
            box:Destroy()
            box = nil
            isClicking = false
        end
    end
end)
